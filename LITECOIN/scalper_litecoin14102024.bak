import http.client
import json
import time
import logging
import secrets
from datetime import datetime
import pandas as pd
import numpy as np
from cryptography.hazmat.primitives import serialization
import jwt
import requests
import random

################################################################################################################################

# Αρχικές μεταβλητές - πρέπει να οριστούν

# Crypto asset to scalping
CRYPTO_SYMBOL = "LTC-EUR"
CRYPTO_NAME = "LTC"
CRYPTO_FULLNAME = "LITECOIN"

# Scalping variables
SCALP_TARGET = 1.01  # 5% κέρδος
TRADE_AMOUNT = 20  # Μονάδα κρυπτονομίσματος

# Technical indicators
short_ma_period = 10  # 5 περιόδων
long_ma_period = 20  # 20 περιόδων
RSI_THRESHOLD = 50  # Βελτιστοποιημένο RSI όριο
GRANULARITY = 300
GRANULARITY_TEXT = "FIVE_MINUTE"

# Ορισμός της μεταβλητής ENABLE_ADDITIONAL_CHECKS
ENABLE_ADDITIONAL_CHECKS = (
    True  # Αλλαγή σε False αν θέλεις να απενεργοποιήσεις τους ελέγχους
)

# Risk Management
STOP_LOSS = 0.99  # 3% κάτω από την τιμή αγοράς

TRAILING_PROFIT_THRESHOLD = 0.05  # Το αφήνουμε όπως είναι
DAILY_PROFIT_TARGET = 30  # Αφήνουμε το ημερήσιο στόχο
MAX_TRADES_PER_DAY = 100  # Μέγιστος αριθμός συναλλαγών ανά ημέρα
start_bot = True

# Tracking variables
daily_profit = 0
current_trades = 0
active_trade = None
highest_price = 0


################################################################################################################################


# Configure logging to both file and console
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(message)s",
    handlers=[
        logging.FileHandler(
            f"/opt/python/scalping-bot/{CRYPTO_FULLNAME}/{CRYPTO_NAME}_bot.log"
        ),  # Log to file
        logging.StreamHandler(),  # Log to console
    ],
)


# Path to the state file
state_file = f"/opt/python/scalping-bot/{CRYPTO_FULLNAME}/state.json"


# Your Coinbase API details (you need to define these)
key_name = "organizations/a935a9c0-1188-4df6-b289-3bc9c82328d8/apiKeys/cad2e31e-0159-4731-97d6-a43373845768"
key_secret = "-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEIElQWMXqYUmD9J9ajFEUxYBqCxkDsLXfAgoKY87BynQaoAoGCCqGSM49\nAwEHoUQDQgAEe/nIxWZ27+bnVyIljVripEhfi5B59QgVcWNDqfiGn3PAvGGPqqK/\nGS95NnY0jDImKumL3AF4fcXOh+MaAebSaw==\n-----END EC PRIVATE KEY-----\n"


# Load the state from the file
def load_state():
    global daily_profit, current_trades, active_trade, trade_amount
    try:
        with open(state_file, "r") as f:
            state = json.load(f)
            daily_profit = state.get("daily_profit", 0)
            current_trades = state.get("current_trades", 0)
            active_trade = state.get("active_trade", None)
            trade_amount = state.get("trade_amount", 0)
            logging.info(
                f"Loaded state: daily_profit={round(daily_profit,2)}, current_trades={current_trades}, active_trade={active_trade}, trade_amount={trade_amount}"
            )
    except FileNotFoundError:
        daily_profit = 0
        current_trades = 0
        active_trade = None
        trade_amount = 0
        save_state()  # Αρχικοποίηση του αρχείου αν δεν υπάρχει
        logging.info(
            f"State file not found. Initialized new state: daily_profit={daily_profit}, current_trades={current_trades}, active_trade={active_trade}, trade_amount={trade_amount}"
        )


# Save the state to the file
def save_state():
    state = {
        "daily_profit": daily_profit,
        "current_trades": current_trades,
        "active_trade": active_trade,
        "trade_amount": trade_amount,
    }
    with open(state_file, "w") as f:
        json.dump(state, f)
    logging.info(
        f"Saved state: daily_profit={round(daily_profit, 2)}, current_trades={current_trades}"
    )
    logging.info(
        f"Saved state: active_trade={active_trade}, trade_amount={trade_amount}"
    )


# Συνάρτηση για τη δημιουργία JWT token
def build_jwt(uri):
    # logging.debug(f"Building JWT token for URI: {uri}")
    private_key_bytes = key_secret.encode("utf-8")
    private_key = serialization.load_pem_private_key(private_key_bytes, password=None)

    # JWT payload
    jwt_payload = {
        "sub": key_name,
        "iss": "cdp",
        "nbf": int(time.time()),
        "exp": int(time.time()) + 120,  # Expire in 120 seconds
        "uri": uri,
    }

    # Generate JWT token using ES256
    jwt_token = jwt.encode(
        jwt_payload,
        private_key,
        algorithm="ES256",
        headers={"kid": key_name, "nonce": secrets.token_hex()},
    )
    # logging.debug(f"JWT token generated successfully: {jwt_token}")
    return jwt_token


# Τοποθέτηση εντολών αγοράς/πώλησης με επιπλέον logging
def place_order(side, size, price):
    logging.debug(f"Placing {side.upper()} order for {size} at price {price}")
    request_host = "api.coinbase.com"
    place_order_path = "/api/v3/brokerage/orders"

    # Order data
    order_data = {
        "client_order_id": secrets.token_hex(10),
        "product_id": CRYPTO_SYMBOL,
        "side": "BUY" if side == "buy" else "SELL",
        "order_configuration": {
            "market_market_ioc": {
                "base_size": str(size),
            }
        },
    }

    body = json.dumps(order_data)
    logging.debug(f"Order data: {body}")

    uri = f"POST {request_host}{place_order_path}"
    jwt_token = build_jwt(uri)
    # logging.debug(f"Generated JWT Token: {jwt_token}")

    headers = {
        "Authorization": f"Bearer {jwt_token}",
        "Content-Type": "application/json",
    }

    conn = http.client.HTTPSConnection(request_host)
    try:
        conn.request("POST", place_order_path, body, headers)
        res = conn.getresponse()
        data = res.read().decode("utf-8")

        logging.debug(f"Response Status Code: {res.status}")
        logging.debug(f"Response Data: {data}")

        response_data = json.loads(data)
        if res.status == 200 and response_data.get("success", False):
            logging.info(f"Order placed successfully: {response_data}")
            return response_data
        else:
            error_message = response_data.get("error_response", "Unknown error")
            logging.error(
                f"Failed to place order. Status: {res.status}, Error: {error_message}"
            )
            return None
    except Exception as e:
        logging.error(f"Error making request: {e}")
        return None
    finally:
        conn.close()


# Technical indicators (MA, MACD, RSI)
def calculate_ma(df, period, timeframe=None):
    try:
        # ---------------------------------------
        # Έλεγχος αν το DataFrame έχει DatetimeIndex για να μπορεί να χρησιμοποιηθεί το resample
        if timeframe is not None:
            if not isinstance(
                df.index, (pd.DatetimeIndex, pd.TimedeltaIndex, pd.PeriodIndex)
            ):
                df = (
                    df.copy()
                )  # Δημιουργούμε αντίγραφο του DataFrame για να μην αλλάξουμε το πρωτότυπο
                df.index = pd.to_datetime(
                    df.index
                )  # Μετατροπή του index σε DatetimeIndex

            df = df.resample(
                timeframe
            ).last()  # Χρησιμοποιεί το τελευταίο διαθέσιμο κλείσιμο για το timeframe
        # ---------------------------------------

        ma = df["close"].rolling(window=period).mean()

        return ma
    except Exception as e:
        logging.error(f"Error calculating MA: {e}")
        return None


def calculate_macd(df, timeframe=None):
    try:
        # ---------------------------------------
        # Έλεγχος αν το DataFrame έχει DatetimeIndex για να μπορεί να χρησιμοποιηθεί το resample
        if timeframe is not None:
            if not isinstance(
                df.index, (pd.DatetimeIndex, pd.TimedeltaIndex, pd.PeriodIndex)
            ):
                logging.warning(f"Index type before conversion: {type(df.index)}")
                df = df.copy()
                df.index = pd.to_datetime(
                    df.index
                )  # Μετατροπή του index σε DatetimeIndex
                logging.info(f"Index type after conversion: {type(df.index)}")

            df = df.resample(
                timeframe
            ).last()  # Χρησιμοποιεί το τελευταίο διαθέσιμο κλείσιμο για το timeframe
            logging.info(
                f"Resampled data: {df.index.min()} to {df.index.max()}"
            )  # Έλεγχος resampling
        # ---------------------------------------

        short_ema = df["close"].ewm(span=12, adjust=False).mean()
        long_ema = df["close"].ewm(span=26, adjust=False).mean()
        macd = short_ema - long_ema
        signal = macd.ewm(span=9, adjust=False).mean()

        return macd, signal
    except Exception as e:
        logging.error(f"Error calculating MACD: {e}")
        return None, None


def calculate_rsi(df, period=14, timeframe=None):
    try:
        # ---------------------------------------
        # Έλεγχος αν το DataFrame έχει DatetimeIndex για να μπορεί να χρησιμοποιηθεί το resample
        if timeframe is not None:
            if not isinstance(
                df.index, (pd.DatetimeIndex, pd.TimedeltaIndex, pd.PeriodIndex)
            ):
                logging.warning(f"Index type before conversion: {type(df.index)}")
                df = df.copy()
                df.index = pd.to_datetime(
                    df.index
                )  # Μετατροπή του index σε DatetimeIndex
                logging.info(f"Index type after conversion: {type(df.index)}")

            df = df.resample(
                timeframe
            ).last()  # Χρησιμοποιεί το τελευταίο διαθέσιμο κλείσιμο για το timeframe
            logging.info(
                f"Resampled data: {df.index.min()} to {df.index.max()}"
            )  # Έλεγχος resampling
        # ---------------------------------------

        delta = df["close"].diff(1)
        gain = delta.where(delta > 0, 0)
        loss = -delta.where(delta < 0, 0)
        avg_gain = gain.rolling(window=period).mean()
        avg_loss = loss.rolling(window=period).mean()
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))

        return rsi
    except Exception as e:
        logging.error(f"Error calculating RSI: {e}")
        return None


# Fetch candlestick data from 3 different routes with try catch
def fetch_data():
    logging.debug(f"Fetching data for {CRYPTO_SYMBOL} with granularity: {GRANULARITY}")

    # Διαφορετικά URLs για εναλλακτικές πηγές δεδομένων
    urls = [
        f"https://api.coinbase.com/api/v3/brokerage/market/products/{CRYPTO_SYMBOL}/candles?granularity={GRANULARITY_TEXT}",
        f"https://api.exchange.coinbase.com/products/{CRYPTO_SYMBOL}/candles?granularity={GRANULARITY}",
        f"https://api.coingecko.com/api/v3/coins/{CRYPTO_FULLNAME.lower()}/ohlc?days=1&vs_currency=eur",
    ]

    # Ανακάτεμα των URLs τυχαία
    random.shuffle(urls)

    max_retries = 2
    delay_between_retries = 10

    for url in urls:
        attempts = 0
        while attempts < max_retries:
            try:
                logging.debug(f"Attempt {attempts + 1} to fetch data from {url}")
                conn = http.client.HTTPSConnection(
                    url.split("/")[2]
                )  # Πάρε το host από το URL
                path = "/" + "/".join(url.split("/")[3:])  # Πάρε το path από το URL

                conn.request("GET", path)
                res = conn.getresponse()

                # Έλεγχος του HTTP status code
                if res.status != 200:
                    logging.error(f"Failed to fetch data from {url}: HTTP {res.status}")
                    attempts += 1
                    time.sleep(delay_between_retries)
                    continue

                data = res.read().decode("utf-8")
                logging.debug(f"Raw response from {url}: {data}")

                # Ανάλυση και μετατροπή των δεδομένων σε DataFrame
                candles = json.loads(data)
                if not candles or len(candles) == 0:
                    logging.warning(f"No data fetched from {url}")
                    return None

                if "coingecko" in url:  # Ειδική περίπτωση για το Coingecko API
                    # Το Coingecko επιστρέφει timestamps σε milliseconds
                    df = pd.DataFrame(
                        candles, columns=["time", "open", "high", "low", "close"]
                    )
                    df["time"] = pd.to_datetime(
                        df["time"], unit="ms"
                    )  # Μετατροπή από milliseconds
                else:
                    df = pd.DataFrame(
                        candles,
                        columns=["time", "low", "high", "open", "close", "volume"],
                    )
                    df["time"] = pd.to_datetime(
                        df["time"], unit="s"
                    )  # Μετατροπή από seconds

                return df  # Επιστρέφει τα δεδομένα αν η αίτηση ήταν επιτυχής

            except Exception as e:
                logging.error(
                    f"Error fetching data from {url} (Attempt {attempts + 1}): {e}"
                )
                attempts += 1
                time.sleep(delay_between_retries)

            finally:
                conn.close()

    logging.error("Failed to fetch data from all sources")
    return None  # Επιστρέφει None αν αποτύχουν όλες οι προσπάθειες


# Νέα έκδοση της συνάρτησης get_crypto_price για χρήση με public endpoint (χωρίς authentication)
def get_crypto_price(retries=3, delay=5):
    method = "GET"
    # Δημόσιο endpoint για crypto
    request_path = f"/products/{CRYPTO_SYMBOL}/ticker"
    public_base_url = "https://api.exchange.coinbase.com"

    for attempt in range(retries):
        try:
            # Δημιουργία του πλήρους URL (χωρίς authentication)
            # logging.debug(f"Making request to {public_base_url}{request_path}")
            response = requests.get(f"{public_base_url}{request_path}")
            # logging.debug(f"Response Status Code: {response.status_code}")
            # logging.debug(f"Response Headers: {response.headers}")
            # logging.debug(f"Response Text: {response.text}")

            # Έλεγχος status code
            if response.status_code != 200:
                logging.error(
                    f"Failed to fetch {CRYPTO_NAME} price. Status code: {response.status_code}. Attempt {attempt + 1} of {retries}"
                )
                time.sleep(delay)  # Καθυστέρηση πριν την επόμενη προσπάθεια
                continue

            # Ανάλυση του JSON
            data = response.json()
            if "price" not in data:
                logging.error(
                    f"'price' key missing in API response: {data}. Attempt {attempt + 1} of {retries}"
                )
                time.sleep(delay)  # Καθυστέρηση πριν την επόμενη προσπάθεια
                continue

            # Απόκτηση της τιμής
            price = float(data["price"])
            logging.info(f"Fetched {CRYPTO_NAME} price: {price}")
            return price

        except requests.exceptions.RequestException as e:
            logging.error(
                f"Error fetching {CRYPTO_NAME} price: {e}. Attempt {attempt + 1} of {retries}"
            )
            time.sleep(delay)  # Καθυστέρηση πριν την επόμενη προσπάθεια

    # Αν αποτύχουν όλες οι προσπάθειες
    logging.error(f"Failed to fetch {CRYPTO_NAME} price after {retries} attempts.")
    return None


# Main trading logic (updated)
def execute_scalping_trade(CRYPTO_SYMBOL):
    global daily_profit, current_trades, highest_price, active_trade, trade_amount, start_bot

    logging.info(f"Executing trade logic for {CRYPTO_SYMBOL}")

    if not start_bot:
        logging.info("Bot is stopped.")
        return

    try:
        df = fetch_data()
        if df is None:
            logging.warning("No data fetched. Skipping trade execution.")
            return

        current_price = get_crypto_price()

        if current_price is None:
            logging.error("Failed to fetch current price. Skipping trade execution.")
            return

        logging.debug(f"Current price for {CRYPTO_SYMBOL}: {current_price}")

        # Αν υπάρχει ανοιχτή θέση, έλεγχος για πώληση
        if active_trade:
            logging.info(
                f"Active trade exists at {active_trade}. Checking for sell opportunity."
            )
            try_to_sell_at = active_trade * SCALP_TARGET
            logging.info(f"Trying to sell at {round(try_to_sell_at,2)}.")

            # Έλεγχος συνθηκών πώλησης
            if current_price >= active_trade * SCALP_TARGET:
                logging.info(f"Selling at {current_price} for profit")
                place_order("sell", trade_amount, current_price)
                daily_profit += (current_price - active_trade) * trade_amount
                active_trade = None
                trade_amount = 0
                current_trades += 1
                save_state()  # Αποθήκευση της κατάστασης μετά την πώληση
                return  # Σταματάει η εκτέλεση της συνάρτησης εδώ μετά την πώληση

            else:
                logging.info(
                    f"Sell not achieved. Current price {current_price} did not meet the target sell price of {round(try_to_sell_at,2)}."
                )

            # Έλεγχος stop-loss
            if current_price <= active_trade * STOP_LOSS:
                logging.info(f"Stop-loss triggered. Selling at {current_price}")
                place_order("sell", trade_amount, current_price)
                daily_profit -= (active_trade - current_price) * trade_amount
                active_trade = None
                trade_amount = 0
                current_trades += 1
                save_state()  # Αποθήκευση της κατάστασης μετά την πώληση
                return  # Σταματάει η εκτέλεση της συνάρτησης εδώ μετά την πώληση

            elif current_price < highest_price * (1 - TRAILING_PROFIT_THRESHOLD):
                logging.info(f"Trailing profit sell at {current_price}")
                place_order("sell", trade_amount, current_price)
                daily_profit += (current_price - active_trade) * trade_amount
                active_trade = None
                trade_amount = 0
                current_trades += 1
                save_state()  # Αποθήκευση της κατάστασης μετά την πώληση
                return  # Σταματάει η εκτέλεση της συνάρτησης εδώ μετά την πώληση

            # Ενημέρωση του highest_price μόνο αν η τρέχουσα τιμή είναι μεγαλύτερη
            if current_price > highest_price:
                highest_price = current_price

            logging.debug(f"Updated highest_price to {highest_price}")
            return  # Δεν κάνουμε νέα αγορά αν υπάρχει ανοιχτή θέση

        ##########################################################################################################################################
        ################### ΓΙΑ ΑΓΟΡΑ####################################################

        # Έλεγχος αν υπάρχουν αρκετά δεδομένα για τον υπολογισμό των δεικτών
        if len(df) < max(
            short_ma_period, long_ma_period, 26
        ):  # Μακρύτερη περίοδος για MACD είναι 26
            logging.warning(
                f"Not enough data to calculate indicators. Data length: {len(df)}"
            )
            return

        # Calculate indicators (για αγορά)
        ma_short = calculate_ma(df, short_ma_period).iloc[-1]
        ma_long = calculate_ma(df, long_ma_period).iloc[-1]
        macd, signal = calculate_macd(df)
        rsi = calculate_rsi(df).iloc[-1]

        logging.info(
            f"Indicators: MA_Short={round(ma_short,3)}, MA_Long={round(ma_long,3)}, MACD={round(macd.iloc[-1],3)}, Signal={round(signal.iloc[-1],3)}, RSI={round(rsi,3)}, Current Price={current_price}"
        )
        # Εμφάνιση του εύρους δεδομένων πριν το resample
        # logging.info(f"Data available for SOL-EUR: {df.index.min()} to {df.index.max()}")

        # ---------------------------------------
        # Μετατροπή της στήλης 'time' σε DatetimeIndex, αν υπάρχει
        if "time" in df.columns:
            df["time"] = pd.to_datetime(
                df["time"]
            )  # Μετατροπή της στήλης 'time' σε datetime format
            df.set_index(
                "time", inplace=True
            )  # Ορισμός της στήλης 'time' ως DatetimeIndex
            # logging.info(f"Index converted to DatetimeIndex: {df.index}")
        else:
            # Αν δεν υπάρχει στήλη 'time', δημιουργούμε DatetimeIndex από RangeIndex
            if isinstance(df.index, pd.RangeIndex):
                logging.warning("No valid datetime index. Creating a DatetimeIndex.")
                df.index = pd.date_range(
                    start="2024-10-01", periods=len(df), freq="T"
                )  # Προσαρμόστε το freq ανάλογα
                logging.info(f"New index created: {df.index}")
            else:
                logging.error("No 'time' column or valid index for resampling.")
                return  # Σταματάμε την εκτέλεση, αν δεν υπάρχουν χρονικές πληροφορίες
        # ---------------------------------------

        # ---------------------------------------
        # Συμπληρωματικός Έλεγχος για επιβεβαίωση δεικτών (προαιρετικός)
        if ENABLE_ADDITIONAL_CHECKS:
            # Resampling data σε ωριαίο χρονικό διάστημα
            df_resampled = df.resample(
                "1H"
            ).last()  # Χρησιμοποιεί το τελευταίο διαθέσιμο κλείσιμο κάθε ώρας
            # logging.info(f"Resampled data: {df_resampled.index.min()} to {df_resampled.index.max()}, length: {len(df_resampled)}")

            # Ελέγχουμε αν υπάρχουν αρκετά δεδομένα για υπολογισμό των δεικτών
            if len(df_resampled) < max(
                short_ma_period, long_ma_period, 14
            ):  # Ανάλογα με τις περιόδους που χρησιμοποιείς
                logging.warning(
                    f"Not enough resampled data for calculating indicators. Data length: {len(df_resampled)}"
                )
                return

            # Υπολογισμός τεχνικών δεικτών
            ma_short_long_period = calculate_ma(df_resampled, short_ma_period).iloc[-1]
            ma_long_long_period = calculate_ma(df_resampled, long_ma_period).iloc[-1]
            macd_long, signal_long = calculate_macd(df_resampled)
            rsi_long = calculate_rsi(df_resampled).iloc[-1]

            # Επιβεβαίωση ότι οι δείκτες συμφωνούν και σε ωριαία χρονικά διαστήματα
            if (
                pd.isna(ma_short_long_period)
                or pd.isna(ma_long_long_period)
                or pd.isna(rsi_long)
            ):
                logging.warning(
                    f"Additional check failed: MA_Short_Long={ma_short_long_period}, MA_Long_Long={ma_long_long_period}, MACD_Long={macd_long.iloc[-1]}, Signal_Long={signal_long.iloc[-1]}, RSI_Long={rsi_long}"
                )
                logging.info(
                    f"Indicators are not consistent across multiple timeframes. No buy action will be taken."
                )
                return
            else:
                logging.info(
                    f"Additional check passed: MA_Short_Long={round(ma_short_long_period, 3)}, MA_Long_Long={round(ma_long_long_period, 3)}, MACD_Long={round(macd_long.iloc[-1], 3)}, Signal_Long={round(signal_long.iloc[-1], 3)}, RSI_Long={round(rsi_long, 3)}"
                )
        # ---------------------------------------

        # Αγοραστικό σήμα
        if (
            ma_short > ma_long
            and macd.iloc[-1] > signal.iloc[-1]
            and rsi < RSI_THRESHOLD
        ):
            # if ma_short > ma_long or rsi < RSI_THRESHOLD:        ###### <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< για δοκιμές

            logging.info(
                f"All technical indicators are positive. Initiating a buy at {current_price}."
            )
            place_order("buy", TRADE_AMOUNT, current_price)
            active_trade = current_price  # Ενημέρωση της ανοιχτής θέσης
            trade_amount = TRADE_AMOUNT  # Καταχώρηση του ποσού συναλλαγής
            highest_price = current_price
            current_trades += 1
            save_state()  # Αποθήκευση της κατάστασης μετά την αγορά
        else:
            # logging.info(f"Indicators: MA_Short={round(ma_short,3)}, MA_Long={round(ma_long,3)}, MACD={round(macd.iloc[-1],3)}, Signal={round(signal.iloc[-1],3)}, RSI={round(rsi,3)}, Current Price={current_price}")
            logging.info(
                f"Not all technical indicators are favorable. No buy action will be taken at this time."
            )

        # Έλεγχος αν επιτεύχθηκε το καθημερινό κέρδος ή το όριο συναλλαγών
        if daily_profit >= DAILY_PROFIT_TARGET or current_trades >= MAX_TRADES_PER_DAY:
            logging.info(
                f"Daily profit target reached: {daily_profit}$ or maximum trades executed"
            )
            start_bot = False
            save_state()  # Αποθήκευση κατάστασης όταν σταματάει το bot

    except Exception as e:
        logging.error(f"Exception occurred in execute_scalping_trade: {e}")
        return


# Main loop (updated to load state)
def run_bot():
    logging.info(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
    logging.info("Starting bot...")
    load_state()  # Load the previous state
    execute_scalping_trade(CRYPTO_SYMBOL)
    # save_state()  # Save the state after each execution
    logging.info("Bot execution completed.")


if __name__ == "__main__":
    run_bot()
