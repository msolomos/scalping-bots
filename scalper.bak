import http.client
import json
import time
import logging
import secrets
from datetime import datetime
import pandas as pd
import numpy as np
from cryptography.hazmat.primitives import serialization
import jwt


# Configure logging to both file and console
logging.basicConfig(level=logging.DEBUG, 
                    format='%(asctime)s %(levelname)s %(message)s',
                    handlers=[
                        logging.FileHandler("/opt/python/scalping-bot/scalping_bot.log"),  # Log to file
                        logging.StreamHandler()  # Log to console
                    ])



# Your Coinbase API details (you need to define these)
key_name = "organizations/a935a9c0-1188-4df6-b289-3bc9c82328d8/apiKeys/cad2e31e-0159-4731-97d6-a43373845768"
key_secret = "-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEIElQWMXqYUmD9J9ajFEUxYBqCxkDsLXfAgoKY87BynQaoAoGCCqGSM49\nAwEHoUQDQgAEe/nIxWZ27+bnVyIljVripEhfi5B59QgVcWNDqfiGn3PAvGGPqqK/\nGS95NnY0jDImKumL3AF4fcXOh+MaAebSaw==\n-----END EC PRIVATE KEY-----\n"


# Scalping configuration
SCALP_TARGET = 1.02
STOP_LOSS = 0.98
TRAILING_PROFIT_THRESHOLD = 0.05
DAILY_PROFIT_TARGET = 40
TRADE_AMOUNT = 0.03  # In ETH
MAX_TRADES_PER_DAY = 50
start_bot = True

# Tracking variables
daily_profit = 0
current_trades = 0
active_trade = None
highest_price = 0

# Συνάρτηση για τη δημιουργία JWT token
def build_jwt(uri):
    logging.debug(f"Building JWT token for URI: {uri}")
    private_key_bytes = key_secret.encode('utf-8')
    private_key = serialization.load_pem_private_key(private_key_bytes, password=None)

    # JWT payload
    jwt_payload = {
        'sub': key_name,
        'iss': "cdp",
        'nbf': int(time.time()),
        'exp': int(time.time()) + 120,  # Expire in 120 seconds
        'uri': uri,
    }

    # Generate JWT token using ES256
    jwt_token = jwt.encode(
        jwt_payload,
        private_key,
        algorithm='ES256',
        headers={'kid': key_name, 'nonce': secrets.token_hex()}
    )
    logging.debug(f"JWT token generated successfully: {jwt_token}")
    return jwt_token

# Τοποθέτηση εντολών αγοράς/πώλησης με επιπλέον logging
def place_order(side, size, price):
    logging.debug(f"Placing {side.upper()} order for {size} at price {price}")
    request_host = "api.coinbase.com"
    place_order_path = "/api/v3/brokerage/orders"

    # Order data
    order_data = {
        'client_order_id': secrets.token_hex(10),
        'product_id': 'ETH-EUR',
        'side': 'BUY' if side == 'buy' else 'SELL',
        'order_configuration': {
            'limit_limit_gtc': {
                'base_size': str(size),
                'limit_price': str(price),
                'post_only': False
            }
        }
    }

    body = json.dumps(order_data)
    logging.debug(f"Order data: {body}")

    uri = f"POST {request_host}{place_order_path}"
    jwt_token = build_jwt(uri)
    logging.debug(f"Generated JWT Token: {jwt_token}")

    headers = {
        'Authorization': f'Bearer {jwt_token}',
        'Content-Type': 'application/json'
    }

    conn = http.client.HTTPSConnection(request_host)
    try:
        conn.request("POST", place_order_path, body, headers)
        res = conn.getresponse()
        data = res.read().decode('utf-8')

        logging.debug(f"Response Status Code: {res.status}")
        logging.debug(f"Response Data: {data}")

        response_data = json.loads(data)
        if res.status == 200 and response_data.get("success", False):
            logging.info(f"Order placed successfully: {response_data}")
            return response_data
        else:
            error_message = response_data.get('error_response', 'Unknown error')
            logging.error(f"Failed to place order. Status: {res.status}, Error: {error_message}")
            return None
    except Exception as e:
        logging.error(f"Error making request: {e}")
        return None
    finally:
        conn.close()

# Technical indicators (MA, MACD, RSI)
def calculate_ma(data, period):
    logging.debug(f"Calculating MA for period: {period}")
    return data['close'].rolling(window=period).mean()

def calculate_macd(data, short_period=12, long_period=26, signal_period=9):
    logging.debug(f"Calculating MACD with short_period={short_period}, long_period={long_period}, signal_period={signal_period}")
    short_ema = data['close'].ewm(span=short_period, adjust=False).mean()
    long_ema = data['close'].ewm(span=long_period, adjust=False).mean()
    macd = short_ema - long_ema
    signal = macd.ewm(span=signal_period, adjust=False).mean()
    return macd, signal

def calculate_rsi(data, period=14):
    logging.debug(f"Calculating RSI for period: {period}")
    delta = data['close'].diff(1)
    gain = (delta.where(delta > 0, 0)).fillna(0)
    loss = (-delta.where(delta < 0, 0)).fillna(0)
    avg_gain = gain.rolling(window=period).mean()
    avg_loss = loss.rolling(window=period).mean()
    rs = avg_gain / avg_loss
    return 100 - (100 / (1 + rs))

# Fetch candlestick data from Coinbase API
def fetch_data(symbol, granularity=60):
    logging.debug(f"Fetching data for {symbol} with granularity: {granularity}")
    request_host = "api.exchange.coinbase.com"
    candles_path = f"/products/{symbol}/candles?granularity={granularity}"

    conn = http.client.HTTPSConnection(request_host)
    try:
        conn.request("GET", candles_path)
        res = conn.getresponse()
        data = res.read().decode('utf-8')
        candles = json.loads(data)

        logging.debug(f"Data fetched successfully: {candles[:5]}")  # Log the first few entries
        df = pd.DataFrame(candles, columns=['time', 'low', 'high', 'open', 'close', 'volume'])
        df['time'] = pd.to_datetime(df['time'], unit='s')
        return df
    except Exception as e:
        logging.error(f"Error fetching data: {e}")
        return None
    finally:
        conn.close()

# Main trading logic
def execute_scalping_trade(symbol):
    global daily_profit, current_trades, highest_price, active_trade, start_bot

    logging.debug(f"Executing trade logic for {symbol}")
    
    if not start_bot:
        logging.info("Bot is stopped.")
        return

    df = fetch_data(symbol, granularity=60)
    if df is None:
        logging.warning("No data fetched. Skipping trade execution.")
        return

    # Calculate indicators
    ma_short = calculate_ma(df, 10).iloc[-1]
    ma_long = calculate_ma(df, 50).iloc[-1]
    macd, signal = calculate_macd(df)
    rsi = calculate_rsi(df).iloc[-1]
    last_price = df['close'].iloc[-1]

    logging.debug(f"Indicators: MA_Short={ma_short}, MA_Long={ma_long}, MACD={macd.iloc[-1]}, Signal={signal.iloc[-1]}, RSI={rsi}, Last Price={last_price}")

    # Buy signal: Short MA crosses above Long MA, MACD above signal, RSI < 40
    if ma_short > ma_long and macd.iloc[-1] > signal.iloc[-1] and rsi < 40:
        if not active_trade:
            logging.info(f"Buying at {last_price}")
            place_order('buy', TRADE_AMOUNT, last_price)
            active_trade = last_price
            highest_price = last_price

    # Sell logic: Scalp target, stop-loss, trailing profit
    if active_trade:
        if last_price >= active_trade * SCALP_TARGET:
            logging.info(f"Selling at {last_price} for profit")
            place_order('sell', TRADE_AMOUNT, last_price)
            daily_profit += (last_price - active_trade) * TRADE_AMOUNT
            active_trade = None
            current_trades += 1

        elif last_price <= active_trade * STOP_LOSS:
            logging.info(f"Stop-loss triggered. Selling at {last_price}")
            place_order('sell', TRADE_AMOUNT, last_price)
            daily_profit -= (active_trade - last_price) * TRADE_AMOUNT
            active_trade = None
            current_trades += 1

        elif last_price > highest_price * (1 - TRAILING_PROFIT_THRESHOLD):
            logging.info(f"Trailing profit sell at {last_price}")
            place_order('sell', TRADE_AMOUNT, last_price)
            daily_profit += (last_price - active_trade) * TRADE_AMOUNT
            active_trade = None
            current_trades += 1

        if last_price > highest_price:
            highest_price = last_price

        logging.debug(f"Updated highest_price to {highest_price}")

    # Check if daily profit target or trade limit reached
    if daily_profit >= DAILY_PROFIT_TARGET or current_trades >= MAX_TRADES_PER_DAY:
        logging.info(f"Daily profit target reached: {daily_profit}$ or maximum trades executed")
        start_bot = False

# Main loop
def run_bot():
    logging.info("")
    logging.info("Starting bot...")
    symbol = 'ETH-EUR'
    execute_scalping_trade(symbol)
    logging.debug("Bot execution completed")

if __name__ == "__main__":
    run_bot()




####################################################################################################################################################
# # Configure logging to see the output
# logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(levelname)s %(message)s')

# # Test order configuration
# test_trade_amount = 0.001  # Small test trade amount in ETH
# test_price = 2149  # Set a price close to the current ETH-EUR price for testing

# def test_place_order():
    # logging.info("Placing a test order...")
    
    # # Place a buy order
    # response = place_order('sell', test_trade_amount, test_price)
    
    # # Check the response
    # if response:
        # logging.info(f"Test order placed successfully: {response}")
    # else:
        # logging.error("Failed to place test order.")
    
# if __name__ == "__main__":
    # test_place_order()
####################################################################################################################################################    